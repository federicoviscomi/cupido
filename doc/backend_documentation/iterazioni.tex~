\section{Global table manager}
    In questa iterazione si e' implementato il global table manager o gtm. Il gtm ha diverse responsabilita': 
    \begin{description}
      \item[swarm]: 
	Gestire un insieme(chiamato in seguito swarm) di local table managers o ltm. In particolare gtm deve:
	\begin{itemize}
	  \item 
	    Permettere di aggiungere e rimuovere ltm dallo swarm.
	  \item
	    Controllare la consistenza dello swarm. A questo scopo fa polling degli ltm chiamando 	
	    \begin{verbatim} 
	      LocalTableManagerInterface.isAlive()
	    \end{verbatim}
	    ogni 
	    \begin{verbatim} 
	      GlobalTableManagerInterface.POLLING_DELAY
	    \end{verbatim} 
	    millisecondi.   
	  \item
	    Inoltrare le richieste delle servlet ad un ltm in modo da bilanciare il carico di lavoro tra gli ltm. A questo scopo gli ltm hanno associata una coppia di interi: il primo indica il numero di tavoli correntemente gestiti dall'ltm e il secondo indica il numero massimo di tavoli gestibili dall'ltm. Quando il gtm deve scegliere un ltm sul quale creare un nuovo tavolo, prende dallo swarm un ltm tra quelli che hanno un carico di lavoro piu' basso. Il carico di lavoro o workload di un ltm e' definito come il rapporto tra i tavoli gestiti e il numero massimo di tavoli gestibili.
	\end{itemize}
	Ricapitolando lo swarm deve mantere associazioni tra interfacce ltm e coppie di interi, deve fornire operazioni di:
	\begin{itemize}
	   \item 	
	      Aggiunta con chiave una interfaccia ltm.
	   \item 
	      Rimozione con chiave una interfaccia ltm.
	   \item 	
	      Scelta di un ltm con workload minimo.
	\end{itemize}
	Si e' deciso di usare un ArrayList di record:
	\begin{center}
	  interfaccia ltm, numero di tavoli gestiti, numero di tavoli gestibili
	\end{center}
	Tale lista viene mantenuta ordinata con workload crescente. Questa struttura dati minimizza il tempo di esecuzione dell'operazione piu' frequente e cioe' la scelta di un ltm.  Sia n il numero di ltm allora le complessita' in tempo al caso pessimo delle operazioni dello swarm sono:
	\begin{description}
	  \item[aggiunta]: 
	    O(log(n)) in particolare si tratta di una ricerca binaria.
	  \item[rimozione]
	    O(n) perche' in questo caso non vengono confrontati i workload ma le interfacce.
	  \item[scelta]
	    O(1) perche' in questo caso basta scegliere il primo elemento della lista.
	\end{description}
      \item[tables]:
	Mantenere alcune informazioni riguardo tutti i tavoli in Cupido. Tali informazioni sono tutte e sole quelle necessarie ad un giocatore che vuole unirsi ad una partita o che vuole vedere una partita e sono contenute nella classe 
	\begin{verbatim}
	  TableInfoForClient
	\end{verbatim}
	Ogni tavolo nel gmt e' identificato da un descrittore di tavolo cioe' una istanza di
	\begin{verbatim}
	  TableDescriptor
	\end{verbatim}
	Il gtm deve memorizzare associazioni tra descrittori di tavolo e informazioni del tavolo, inoltre deve avere a disposizione le operazioni di: aggiunta, ricerca e rimozione usando come chiave un descrittore di tavolo. Si e' scelto di memorizzare le informazioni dei tavoli in una tabella hash. L'hash e' calcolato sui campi del descrittore del tavolo. In particolare il descrittore del tavolo contiene: una stringa che identifica un ltm, un intero che identifica il tavolo all'interno dell'ltm. In questo modo le operazioni richiedono tempo costante.
    \end{description}
  Gtm e' usato attraverso RMI quindi il multithreading e' gestito in automatico dalla JVM. La mutua eclusione sul ltm e' gestita semplicemente usando metodi synchronized. E' stata presa in considerazione un'altra strategia di mutua eclusione meno restrittiva cioe': tutte le operazioni hanno accesso esclusivo all'ltm con l'eccezione che si permettono piu' operazioni in lettura allo stesso tempo. Tuttavia questa soluzione presenta il problema della starvation delle operazioni di scrittura quindi si e' deciso di non adottarla.


\section{Local table manager}
  In questa iterazione si e' implementato il local table manager o ltm. Ltm si occupa di una porzione dei tavoli di Cupido. In particolare ltm fornisce le operazioni seguenti:
  \begin{itemize}
    \item 
      Creare componenti table chiamate in seguito single table manager o stm.
    \item 
      Rimuovere un stm quando una partita finisce.
    \item 
      Cercare un stm quando un giocatore vuole unirsi ad una partita o guardare una partita.
  \end{itemize}
  Ltm mantiene in una tabella hash gli stm indicizzati da un intero che identifica l'stm in modo univoco nell'ltm. In questo modo le operazioni dell'ltm hanno complessita' in tempo costante.
  Per quanto riguarda il multithreading e la mutua eclusione valgono le stesse cose dette per il gtm.

\section{Console gtm and ltm UI}
  In questa iterazione sono state implementate due interpreti di comandi da console minimali per gtm ed ltm. I comandi forniti permettono di vedere lo stato interno dei gtm e degli ltm. Quindi questi interpreti hanno una valenza per lo piu' in fase di debug/test.

\section{Global chat}
  In questa iterazione e' stata implementata la chat globale lato backend. La chat globale e' un buffer di dimensione fissa di messaggi. Gli utenti di Cupido possono solo scrivere messaggi o reperire un certo numero di ultimi messaggi. Quindi i client fanno polling della chat globale e non ricevono notifiche quando un client invia un messaggio nella chat globale. Questo perche' si prevede la possibilita' di avere un numero elevato di utenti e quindi non conviene che la chat globale memorizzi un interfaccia di notifica per ognuno di essi e che invii notifiche a questa interfaccia ogni volta che arriva un nuovo messaggio nella chat globale.

\section{Database Manager}
  In questa iterazione e' stata implementata la classe DatabaseManager che fornisce le operazioni descritte in SRS.

\section{Single table manager and game logic}

\section{Bot}


\section{Console player UI}

\section{Changed communication, control flow and mutual exclusion}
major changes in control flow, mutual exclusion and communication:
    using action queue for: local bot, stm and automatic servlet.
    automatic servlet queue commands received from the UI, and execute them later if they can't be executed rigth now. AutomaticServlet enqueue all incoming messages in an action queue and process them sequentially.
    ViewersSwarm: all notifications to servlets are now enqueued in an action queue.
    STM: Use an action queue to avoid deadlocks. completely changed communication between stm, local bot and player ui.
