\section{Global table manager}
    In questa iterazione si e' implementato il global table manager o gtm. Il gtm ha diverse responsabilita': 
    \begin{description}
      \item[swarm]: 
	Gestire un insieme(chiamato in seguito swarm) di local table managers o ltm. In particolare gtm deve:
	\begin{itemize}
	  \item 
	    Permettere di aggiungere e rimuovere ltm dallo swarm.
	  \item
	    Controllare la consistenza dello swarm. A questo scopo fa polling degli ltm chiamando 	
	    \begin{verbatim} 
	      LocalTableManagerInterface.isAlive()
	    \end{verbatim}
	    ogni 
	    \begin{verbatim} 
	      GlobalTableManagerInterface.POLLING_DELAY
	    \end{verbatim} 
	    millisecondi.   
	  \item
	    Inoltrare le richieste delle servlet ad un ltm in modo da bilanciare il carico di lavoro tra gli ltm. A questo scopo gli ltm hanno associata una coppia di interi: il primo indica il numero di tavoli correntemente gestiti dall'ltm e il secondo indica il numero massimo di tavoli gestibili dall'ltm. Quando il gtm deve scegliere un ltm sul quale creare un nuovo tavolo, prende dallo swarm un ltm tra quelli che hanno un carico di lavoro piu' basso. Il carico di lavoro o workload di un ltm e' definito come il rapporto tra i tavoli gestiti e il numero massimo di tavoli gestibili.
	\end{itemize}
	Ricapitolando lo swarm deve mantere associazioni tra interfacce ltm e coppie di interi, deve fornire operazioni di:
	\begin{itemize}
	   \item 	
	      Aggiunta con chiave una interfaccia ltm.
	   \item 
	      Rimozione con chiave una interfaccia ltm.
	   \item 	
	      Scelta di un ltm con workload minimo.
	\end{itemize}
	Si e' deciso di usare un ArrayList di record:
	\begin{center}
	  interfaccia ltm, numero di tavoli gestiti, numero di tavoli gestibili
	\end{center}
	Tale lista viene mantenuta ordinata con workload crescente. Questa struttura dati minimizza il tempo di esecuzione dell'operazione piu' frequente e cioe' la scelta di un ltm.  Sia n il numero di ltm allora le complessita' in tempo al caso pessimo delle operazioni dello swarm sono:
	\begin{description}
	  \item[aggiunta]: 
	    O(log(n)) in particolare si tratta di una ricerca binaria.
	  \item[rimozione]
	    O(n) perche' in questo caso non vengono confrontati i workload ma le interfacce.
	  \item[scelta]
	    O(1) perche' in questo caso basta scegliere il primo elemento della lista.
	\end{description}
      \item[tables]:
	Mantenere alcune informazioni riguardo tutti i tavoli in Cupido. Tali informazioni sono tutte e sole quelle necessarie ad un giocatore che vuole unirsi ad una partita o che vuole vedere una partita e sono contenute nella classe 
	\begin{verbatim}
	  TableInfoForClient
	\end{verbatim}
	Ogni tavolo nel gmt e' identificato da un descrittore di tavolo cioe' una istanza di
	\begin{verbatim}
	  TableDescriptor
	\end{verbatim}
	Il gtm deve memorizzare associazioni tra descrittori di tavolo e informazioni del tavolo, inoltre deve avere a disposizione le operazioni di: aggiunta, ricerca e rimozione usando come chiave un descrittore di tavolo. Si e' scelto di memorizzare le informazioni dei tavoli in una tabella hash. L'hash e' calcolato sui campi del descrittore del tavolo. In particolare il descrittore del tavolo contiene: una stringa che identifica un ltm, un intero che identifica il tavolo all'interno dell'ltm. In questo modo le operazioni richiedono tempo costante.
    \end{description}
  Gtm e' usato attraverso RMI quindi il multithreading e' gestito in automatico dalla JVM. La mutua eclusione sul gtm e' gestita semplicemente usando metodi \begin{verbatim}
    synchronized
  \end{verbatim} 
  E' stata presa in considerazione un'altra strategia di mutua eclusione meno restrittiva cioe': tutte le operazioni hanno accesso esclusivo all gtm con l'eccezione che si permettono piu' operazioni in lettura allo stesso tempo. Tuttavia questa soluzione presenta il problema della starvation delle operazioni di scrittura quindi si e' deciso di non adottarla.


\section{Local table manager}
  In questa iterazione si e' implementato il local table manager o ltm. Ltm si occupa di una porzione dei tavoli di Cupido. In particolare ltm fornisce le operazioni seguenti:
  \begin{itemize}
    \item 
      Creare componenti table chiamate in seguito single table manager o stm.
    \item 
      Rimuovere un stm quando una partita finisce.
    \item 
      Cercare un stm quando un giocatore vuole unirsi ad una partita o guardare una partita.
  \end{itemize}
  Ltm mantiene in una tabella hash gli stm indicizzati da un intero che identifica l'stm in modo univoco nell'ltm. In questo modo le operazioni dell'ltm hanno complessita' in tempo costante.
  Per quanto riguarda il multithreading e la mutua eclusione valgono le stesse cose dette per il gtm.

\section{Gtm and ltm console UI}
  In questa iterazione sono state implementati due interpreti di comandi da console minimali per gtm ed ltm. I comandi forniti permettono di vedere lo stato interno del gtm e degli ltm. Quindi questi interpreti hanno una valenza per lo piu' in fase di debug e test. Potrebbero essere usati anche in un deploy reale per operazioni di manutenzione ma si e' scelto di non farlo perche' non serve: in particolare non ci sono requisiti che vietano di riavviare il gtm o gli ltm in fase di esecuzione.

\section{Global chat}
  In questa iterazione e' stata implementata la chat globale lato backend. La chat globale e' un buffer di dimensione fissa di messaggi. Gli utenti di Cupido possono solo scrivere messaggi o reperire un certo numero di ultimi messaggi. Quindi i client fanno polling della chat globale e non ricevono notifiche quando un client invia un messaggio nella chat globale. Questo perche' si prevede la possibilita' di avere un numero elevato di utenti e quindi non conviene che la chat globale memorizzi un interfaccia di notifica per ognuno di essi e che invii notifiche a questa interfaccia ogni volta che arriva un nuovo messaggio nella chat globale.

\section{Database Manager}
  In questa iterazione e' stata implementata la classe DatabaseManager che fornisce le operazioni descritte in SRS.

\section{Single table manager and game logic}
  In questa iterazione e' stato implementato stm. Stm si occupa di una singola partita. In particolare stm:
  \begin{itemize}
    \item 
      gestisce i giocatori 
    \item
      gestisce i visitatori
    \item
      gestisce le carte
    \item
      gestisce i bot
    \item
      controlla che le mosse dei giocatori siano valide
    \item 
      da le carte
    \item
      aggiorna i punteggi dei giocatori.
  \end{itemize}

\section{Bot}
  In questa iterazione e' stato implementato un bot, cioe' un giocatore automatico. Quando il bot riceve le carte le ordina dalla piu' alta alla piu' bassa e poi in base al seme. Quando deve passare le carte sceglie le prime tre che ha. Quando deve giocare una carta sceglie la prima carta valida che ha.

\section{Console player UI}
  In questa iterazione e' stato implementato un interprete di comandi testuale per un utente di Cupido. L'interprete fornisce una ampia gamma di comandi: creare un tavolo, ottenere la lista di tutti i tavoli, unirsi ad una partita, vedere una partita, giocare una carta qualsiasi o una carta specifica, passare delle carte qualsiasi o delle carte specifiche. I comandi possono essere presi da console o da un file di input. Usando un file di input si puo' far giocare una partita a degli utenti in modo completamente automatico.
